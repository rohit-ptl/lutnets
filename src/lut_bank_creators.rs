use crate::settings::*;
use rand::{Rng, SeedableRng};
use rand_xoshiro::Xoshiro256PlusPlus;
use std::collections::HashSet;

// This file is needed only if you are using networks with a fixed and finite LUT bank.
// What that means is that each LUT in the network will be one of the ones in the bank
// and not an arbitrary u64. And I haven't really put a ton of effort into shaping these
// banks properly. The various functions in this file are largely generated by an LLM.
// And while I have verified that it does what it is meant to, the quality and diversity
// of LUT banks generated are not verified.

// Grenerate the 256 LUTs randomly
pub fn generate_luts(cfg: &Configuration) -> Option<Vec<u64>> {
    if cfg.network.lut_bank_size == 0 {
        return None;
    }
    let mut rng: Xoshiro256PlusPlus = Xoshiro256PlusPlus::from_rng(&mut rand::rng());
    let mut luts = vec![0u64; cfg.network.lut_bank_size];
    rng.fill(&mut luts[..]);
    Some(luts)
}

fn build_lut(logic_fn: impl Fn(bool, bool, bool, bool, bool, bool) -> bool) -> u64 {
    let mut lut = 0u64;
    for i in 0..64 {
        // Deconstruct the index 'i' into 6 boolean inputs.
        let i0 = (i & 1) != 0;
        let i1 = (i & 2) != 0;
        let i2 = (i & 4) != 0;
        let i3 = (i & 8) != 0;
        let i4 = (i & 16) != 0;
        let i5 = (i & 32) != 0;

        if logic_fn(i0, i1, i2, i3, i4, i5) {
            lut |= 1 << i;
        }
    }
    lut
}

/// Generates and returns an array of 16 diverse 6-input LUTs.
pub fn generate_diverse_16_luts() -> Option<Vec<u64>> {
    Some(
        [
            // 1. Constant Zero: Always outputs 0.
            build_lut(|_, _, _, _, _, _| false),
            // 2. Constant One: Always outputs 1.
            build_lut(|_, _, _, _, _, _| true),
            // 3. Identity/Passthrough (LSB): Output is equal to the first input (i0).
            // Creates a repeating 0101... pattern.
            build_lut(|i0, _, _, _, _, _| i0),
            // 4. Identity/Passthrough (MSB): Output is equal to the last input (i5).
            // Creates a pattern of 32 zeros followed by 32 ones.
            build_lut(|_, _, _, _, _, i5| i5),
            // 5. Simple AND: A 2-input AND gate (i0 AND i1). A very sparse function.
            build_lut(|i0, i1, _, _, _, _| i0 && i1),
            // 6. Simple OR: A 2-input OR gate (i0 OR i1). A very dense function.
            build_lut(|i0, i1, _, _, _, _| i0 || i1),
            // 7. Simple XOR: A 2-input XOR gate (i0 XOR i1). Perfectly balanced.
            build_lut(|i0, i1, _, _, _, _| i0 ^ i1),
            // 8. Full 6-input AND: True only when all inputs are true. The sparsest non-zero LUT.
            build_lut(|i0, i1, i2, i3, i4, i5| i0 && i1 && i2 && i3 && i4 && i5),
            // 9. Full 6-input OR: True if any input is true. The densest non-one LUT.
            build_lut(|i0, i1, i2, i3, i4, i5| i0 || i1 || i2 || i3 || i4 || i5),
            // 10. Full 6-input XOR (Parity): True if an odd number of inputs are true. A linear function.
            build_lut(|i0, i1, i2, i3, i4, i5| i0 ^ i1 ^ i2 ^ i3 ^ i4 ^ i5),
            // 11. Full 6-input XNOR (Equality Check): The inverse of the parity function.
            build_lut(|i0, i1, i2, i3, i4, i5| !(i0 ^ i1 ^ i2 ^ i3 ^ i4 ^ i5)),
            // 12. Majority Function: True if 3 or more inputs are true. A classic symmetric function.
            build_lut(|i0, i1, i2, i3, i4, i5| {
                let count = i0 as u8 + i1 as u8 + i2 as u8 + i3 as u8 + i4 as u8 + i5 as u8;
                count >= 3
            }),
            // 13. 2-to-1 Multiplexer (Mux): Selects between i0 and i1 using i2 as the selector.
            build_lut(|i0, i1, i2, _, _, _| if i2 { i1 } else { i0 }),
            // 14. Complex Non-Linear Function: An arbitrary combination of gates.
            build_lut(|i0, i1, i2, i3, i4, i5| (i0 && i1) ^ (i2 && i3) || (i4 && i5)),
            // 15. A pseudo-random constant: This large prime number has no simple logical structure.
            0xA3B1_C5D7_E9F2_041B,
            // 16. Checkerboard Pattern: A linear function of alternating inputs (i0 ^ i2 ^ i4).
            build_lut(|i0, _, i2, _, i4, _| i0 ^ i2 ^ i4),
        ]
        .to_vec(),
    )
}

/// Helper to build a linear function LUT from a 6-bit mask.
/// A linear function is any combination of XORs of the inputs.
fn build_linear_lut(linear_mask: u8) -> u64 {
    build_lut(|i0, i1, i2, i3, i4, i5| {
        let mut result = false;
        if (linear_mask & 1) != 0 {
            result ^= i0;
        }
        if (linear_mask & 2) != 0 {
            result ^= i1;
        }
        if (linear_mask & 4) != 0 {
            result ^= i2;
        }
        if (linear_mask & 8) != 0 {
            result ^= i3;
        }
        if (linear_mask & 16) != 0 {
            result ^= i4;
        }
        if (linear_mask & 32) != 0 {
            result ^= i5;
        }
        result
    })
}

/// Helper to build a symmetric function LUT from a 7-bit mask.
/// A symmetric function's output depends only on the number of true inputs (popcount).
fn build_symmetric_lut(symmetric_mask: u8) -> u64 {
    // The mask has 7 bits, one for each possible popcount (0 through 6).
    build_lut(|i0, i1, i2, i3, i4, i5| {
        let popcount = i0 as u8 + i1 as u8 + i2 as u8 + i3 as u8 + i4 as u8 + i5 as u8;
        (symmetric_mask >> popcount) & 1 != 0
    })
}

/// Generates and returns an array of 256 diverse 6-input LUTs.
pub fn generate_diverse_256_luts() -> Option<Vec<u64>> {
    let mut all_luts = Vec::new();

    // 1. Generate all 64 linear functions (XOR combinations of inputs).
    // Includes constant 0 and parity checks on all subsets of inputs.
    for i in 0..64 {
        all_luts.push(build_linear_lut(i));
    }

    // 2. Generate all 128 symmetric functions.
    // Includes constant 1, majority vote, and functions like "true if exactly 2 inputs are true".
    for i in 0..128 {
        all_luts.push(build_symmetric_lut(i));
    }

    // 3. Generate all 15 two-input AND gates and 15 two-input OR gates.
    for i in 0..6 {
        for j in (i + 1)..6 {
            // AND gate between input i and input j
            all_luts.push(build_lut(|i0, i1, i2, i3, i4, i5| {
                let ins = [i0, i1, i2, i3, i4, i5];
                ins[i] && ins[j]
            }));
            // OR gate between input i and input j
            all_luts.push(build_lut(|i0, i1, i2, i3, i4, i5| {
                let ins = [i0, i1, i2, i3, i4, i5];
                ins[i] || ins[j]
            }));
        }
    }

    // 4. Generate a selection of 2-to-1 multiplexers.
    // Selects between input i and j using k as the selector.
    for i in 0..6 {
        for j in (i + 1)..6 {
            for k in 0..6 {
                if k == i || k == j {
                    continue;
                } // Selector must be a different input
                all_luts.push(build_lut(|i0, i1, i2, i3, i4, i5| {
                    let ins = [i0, i1, i2, i3, i4, i5];
                    if ins[k] { ins[j] } else { ins[i] }
                }));
            }
        }
    }

    // Remove duplicates and collect into a new vector.
    // Some functions are both linear and symmetric (e.g., constant 0, full parity).
    let unique_luts: HashSet<u64> = all_luts.into_iter().collect();
    let mut final_luts: Vec<u64> = unique_luts.into_iter().collect();

    // Sort to make the output deterministic.
    final_luts.sort();

    // In case we generated fewer than 256 unique LUTs, pad with pseudo-random constants.
    let mut random_seed = 0x_C0FFEE_BABE_D00D_u64;
    while final_luts.len() < 256 {
        // Use a simple Linear Congruential Generator to get new values
        random_seed = random_seed
            .wrapping_mul(6364136223846793005)
            .wrapping_add(1442695040888963407);
        if !final_luts.contains(&random_seed) {
            final_luts.push(random_seed);
        }
    }

    // Truncate to exactly 256 and convert to a fixed-size array.
    final_luts.truncate(256);
    Some(final_luts)
}
